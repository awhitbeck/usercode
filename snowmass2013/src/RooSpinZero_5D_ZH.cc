 /***************************************************************************** 
  * Project: RooFit                                                           * 
  *                                                                           * 
  * This code was autogenerated by RooClassFactory                            * 
  *****************************************************************************/ 

 // Your description goes here... 

 #include "Riostream.h" 

 #include "RooSpinZero_5D_ZH.h" 
 #include "RooAbsReal.h" 
 #include "RooAbsCategory.h" 

#include <math.h>
#include "TMath.h"

using namespace TMath;


 ClassImp(RooSpinZero_5D_ZH) 

 RooSpinZero_5D_ZH::RooSpinZero_5D_ZH(const char *name, const char *title, 
                        RooAbsReal& _h1,
                        RooAbsReal& _h2,
                        RooAbsReal& _hs,
                        RooAbsReal& _Phi,
			RooAbsReal& _Phi1,
			RooAbsReal& _sqrts,
			RooAbsReal& _mH,
    	                RooAbsReal& _mZ,
			RooAbsReal& _a1,
			RooAbsReal& _a2,
			RooAbsReal& _a3,
			RooAbsReal& _phia1,
			RooAbsReal& _phia2,
			RooAbsReal& _phia3,
			RooAbsReal& _R1Val,
                        RooAbsReal& _R2Val) :
   RooAbsPdf(name,title), 
   h1("h1","h1",this,_h1),
   h2("h2","h2",this,_h2),
   hs("hs","hs",this,_hs),
   Phi("Phi","Phi",this,_Phi),
   Phi1("Phi1","Phi1",this,_Phi1),
   sqrts("sqrts","sqrts",this,_sqrts),
   mH("mH","mH",this,_mH),
   mZ("mZ","mZ",this,_mZ),
   a1("a1","a1",this,_a1),
   a2("a2","a2",this,_a2),
   a3("a3","a3",this,_a3),
   phia1("phia1","phia1",this,_phia1),
   phia2("phia2","phia2",this,_phia2),
   phia3("phia3","phia3",this,_phia3),
   R1Val("R1Val","R1Val",this,_R1Val),
   R2Val("R2Val","R2Val",this,_R2Val)
 { 
 } 


 RooSpinZero_5D_ZH::RooSpinZero_5D_ZH(const RooSpinZero_5D_ZH& other, const char* name) :  
   RooAbsPdf(other,name), 
   h1("h1",this,other.h1),
   h2("h2",this,other.h2),
   hs("hs",this,other.hs),
   Phi("Phi",this,other.Phi),
   Phi1("Phi1",this,other.Phi1),
   sqrts("sqrts",this,other.sqrts),
   mH("mH",this,other.mH),
   mZ("mZ",this,other.mZ),
   a1("a1",this,other.a1),
   a2("a2",this,other.a2),
   a3("a3",this,other.a3),
   phia1("phia1",this,other.phia1),
   phia2("phia2",this,other.phia2),
   phia3("phia3",this,other.phia3),
   R1Val("R1Val",this,other.R1Val),
   R2Val("R2Val",this,other.R2Val)
 { 
 } 



 Double_t RooSpinZero_5D_ZH::evaluate() const 
 { 

   // these amplitudes are calculated based on comparing equations to the PRD paper
   // the beta and gamma are velocities of the Z in the C.O.M
   // Double_t betaValSquared =(pow(sqrts,2)-(pow(mH+mZ,2)))*(pow(sqrts,2)-(pow(mH-mZ,2)))/pow(pow(sqrts,2)-mH*mH+mZ*mZ,2);
   // Double_t gamma = 1./sqrt(1-betaValSquared);
      // http://prd.aps.org/pdf/PRD/v49/i1/p79_1
   // Double_t f00 = gamma*gamma/(2+gamma*gamma);

   // below calcualtions are based on the H->ZZ amplitudes 
   Double_t x = pow((mH*mH-sqrts*sqrts-mZ*mZ)/(2.*sqrts*mZ),2)-1;
   
   Double_t A00Real = - (a1*cos(phia1)*sqrt(1+x) + a2*cos(phia2)*(mZ*sqrts)/(mH*mH)*x);
   Double_t A00Imag = a1*sin(phia1)*sqrt(1+x) + a2*sin(phia2)*(mZ*sqrts)/(mH*mH)*x;

   Double_t Ap0Real = a1*cos(phia1) - a3*sin(phia3)*(mZ*sqrts)/(mH*mH)*sqrt(x);
   Double_t Ap0Imag = a1*sin(phia1) + a3*cos(phia3)*(mZ*sqrts)/(mH*mH)*sqrt(x);

   Double_t Am0Real = a1*cos(phia1) + a3*sin(phia3)*(mZ*sqrts)/(mH*mH)*sqrt(x);
   Double_t Am0Imag = a1*sin(phia1) - a3*cos(phia3)*(mZ*sqrts)/(mH*mH)*sqrt(x);

   Double_t f00 = A00Real*A00Real + A00Imag*A00Imag;
   Double_t fp0 = Ap0Real*Ap0Real + Ap0Imag*Ap0Imag;
   Double_t fm0 = Am0Real*Am0Real + Am0Imag*Am0Imag;
   
   Double_t ftotal = f00 + fp0 + fm0;
   
   // normalize to the total
   f00 = f00 / ftotal;
   fp0 = fp0 / ftotal;
   fm0 = fm0 / ftotal;
   
   Double_t phi00=atan2(A00Imag,A00Real);
   Double_t phip0=atan2(Ap0Imag,Ap0Real)-phi00;
   Double_t phim0=atan2(Am0Imag,Am0Real)-phi00;
   
   Double_t value = 0;
   

   value += (f00*(-1 + Power(h1,2))*(-1 + Power(h2,2)))/4.;

   value += (fp0*(1 + Power(h1,2) + 2*h1*R1Val)*(1 + Power(h2,2) + 2*h2*R2Val))/16.;

   value += (fm0*(1 + Power(h1,2) - 2*h1*R1Val)*(1 + Power(h2,2) - 2*h2*R2Val))/16.;

   value += (Sqrt(f00)*Sqrt(fp0)*Sqrt(1 - Power(h1,2))*Sqrt(1 - Power(h2,2))*(h1 - R1Val)*(h2 - R2Val)*Cos(Phi1 + phip0))/4.;

   value += (Sqrt(f00)*Sqrt(fm0)*Sqrt(1 - Power(h1,2))*Sqrt(1 - Power(h2,2))*(h1 + R1Val)*(h2 - R2Val)*Cos(Phi1 - phim0))/4.;

   value += (Sqrt(fm0)*Sqrt(fp0)*(-1 + Power(h1,2))*(-1 + Power(h2,2))*Cos(2*Phi1 - phim0 + phip0))/8.;


   return value ; 
 } 

Int_t RooSpinZero_5D_ZH::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{
  
  if (matchArgs(allVars,analVars,RooArgSet(*h1.absArg(),*h2.absArg(),*hs.absArg(),*Phi.absArg(),*Phi1.absArg()))) return 6 ;
  if (matchArgs(allVars,analVars,h1,h2,Phi,Phi1)) return 1 ;
  if (matchArgs(allVars,analVars,h1,h2,hs,Phi)) return 2 ;
  if (matchArgs(allVars,analVars,h1,hs,Phi,Phi1)) return 3 ;
  if (matchArgs(allVars,analVars,h2,hs,Phi,Phi1)) return 4 ;
  if (matchArgs(allVars,analVars,h1,h2,hs,Phi1)) return 5 ;
  
  return 0 ;
}

Double_t RooSpinZero_5D_ZH::analyticalIntegral(Int_t code, const char* rangeName) const
{
   
    // the beta and gamma are velocities of the Z in the C.O.M
   Double_t betaValSquared =(pow(sqrts,2)-(pow(mH+mZ,2)))*(pow(sqrts,2)-(pow(mH-mZ,2)))/pow(pow(sqrts,2)-mH*mH+mZ*mZ,2);
   Double_t gamma = 1./sqrt(1-betaValSquared);

   // these amplitudes are calculated based on comparing equations to the PRD paper
   // http://prd.aps.org/pdf/PRD/v49/i1/p79_1
   // Double_t f00 = gamma*gamma/(2+gamma*gamma);
  
    // below calcualtions are based on the H->ZZ amplitudes 
   Double_t x = pow((mH*mH-sqrts*sqrts-mZ*mZ)/(2.*sqrts*mZ),2)-1;
   
   Double_t A00Real = - (a1*cos(phia1)*sqrt(1+x) + a2*cos(phia2)*(mZ*sqrts)/(mH*mH)*x);
   Double_t A00Imag = a1*sin(phia1)*sqrt(1+x) + a2*sin(phia2)*(mZ*sqrts)/(mH*mH)*x;

   Double_t Ap0Real = a1*cos(phia1) - a3*sin(phia3)*(mZ*sqrts)/(mH*mH)*sqrt(x);
   Double_t Ap0Imag = a1*sin(phia1) + a3*cos(phia3)*(mZ*sqrts)/(mH*mH)*sqrt(x);

   Double_t Am0Real = a1*cos(phia1) + a3*sin(phia3)*(mZ*sqrts)/(mH*mH)*sqrt(x);
   Double_t Am0Imag = a1*sin(phia1) - a3*cos(phia3)*(mZ*sqrts)/(mH*mH)*sqrt(x);

   Double_t f00 = A00Real*A00Real + A00Imag*A00Imag;
   Double_t fp0 = Ap0Real*Ap0Real + Ap0Imag*Ap0Imag;
   Double_t fm0 = Am0Real*Am0Real + Am0Imag*Am0Imag;

   Double_t ftotal = f00 + fp0 + fm0;
   
   // normalize to the total
   f00 = f00 / ftotal;
   fp0 = fp0 / ftotal;
   fm0 = fm0 / ftotal;
   
   Double_t phi00=atan2(A00Imag,A00Real);
   Double_t phip0=atan2(Ap0Imag,Ap0Real)-phi00;
   Double_t phim0=atan2(Am0Imag,Am0Real)-phi00;

   switch(code)
     {
       // projections to hs
     case 1:
       {

	 double value = 0.;

	 value += (16*f00*Power(Pi(),2))/9.;
	 
	 value += (16*fp0*Power(Pi(),2))/9.;
	 
	 value += (16*fm0*Power(Pi(),2))/9.;


	 return value;

       }
       // projections to Phi1
     case 2:
       {

	 double value = 0.;

	 value += (16*f00*Pi())/9.;
	 
	 value += (16*fp0*Pi())/9.;
	 
	 value += (16*fm0*Pi())/9.;

	 return value;

       }
       // projections to h2
     case 3:
       {


	 double value = 0.;
	 
	 value += (-8*f00*(-1 + Power(h2,2))*Power(Pi(),2))/3.;

	 value += (4*fp0*Power(Pi(),2)*(1 + Power(h2,2) + 2*h2*R2Val))/3.;

	 value += (4*fm0*Power(Pi(),2)*(1 + Power(h2,2) - 2*h2*R2Val))/3.;
	 
	 return value;

       }
       // projections to h1
     case 4:
       {

	 double value = 0;
	 
	 value += (-8*f00*(-1 + Power(h1,2))*Power(Pi(),2))/3.;

	 value += (4*fp0*Power(Pi(),2)*(1 + Power(h1,2) + 2*h1*R1Val))/3.;

	 value += (4*fm0*Power(Pi(),2)*(1 + Power(h1,2) - 2*h1*R1Val))/3.;

	 return value;

       }
       // projections to Phi
     case 5:
       {


	 double value = 0.;
	 
	 value += (16*f00*Pi())/9.;

	 value += (16*fp0*Pi())/9.;
	 
	 value += (16*fm0*Pi())/9.;
	 
	 value += -(Sqrt(f00)*Sqrt(fp0)*Power(Pi(),3)*R1Val*R2Val*Cos(Phi + phip0))/4.;

	 value += -(Sqrt(f00)*Sqrt(fm0)*Power(Pi(),3)*R1Val*R2Val*Cos(Phi - phim0))/4.;

	 value += (8*sqrt(fm0)*sqrt(fp0)*Pi()*Cos(2*Phi - phim0 + phip0))/9.;
	 
	 return value;

       }
       // projected everything
     case 6:
       {
	 double value = 0.;
	 
	 value += (32*f00*Power(Pi(),2))/9.;
	 
	 value += (32*fp0*Power(Pi(),2))/9.;
	 
	 value += (32*fm0*Power(Pi(),2))/9.;
	 
	 return value;
       }
     }
   assert(0) ;
   return 0 ;
}



