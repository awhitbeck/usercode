/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "RooSpinZero_7DComplex_withAccep.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

using namespace TMath;

enum parameterizationList {kMagPhase_As=0,kRealImag_Gs=1,kFracPhase_Gs=2,kNUMparameterizations=3};

RooSpinZero_7DComplex_withAccep::RooSpinZero_7DComplex_withAccep(const char *name, const char *title,
	                                                         measurables _measurables,
                                                                 modelParameters _modelParams,
	                                                         accepParameters _accepParams) :
  RooAbsPdf(name,title),
  m1("m1","m1",this,_measurables._m1),
  m2("m2","m2",this,_measurables._m2),
  h1("h1","h1",this,_measurables._h1),
  h2("h2","h2",this,_measurables._h2),
  hs("hs","hs",this,_measurables._hs),
  Phi("Phi","Phi",this,_measurables._Phi),
  Phi1("Phi1","Phi1",this,_measurables._Phi1),
  a1Val("a1Val","a1Val",this,_modelParams._a1Val),
  phi1Val("phi1Val","phi1Val",this,_modelParams._phi1Val),
  a2Val("a2Val","a2Val",this,_modelParams._a2Val),
  phi2Val("phi2Val","phi2Val",this,_modelParams._phi2Val),
  a3Val("a3Val","a3Val",this,_modelParams._a3Val),
  phi3Val("phi3Val","phi3Val",this,_modelParams._phi3Val),
  parameterization(_modelParams._parameterization),
  g1Val("g1Val","g1Val",this,_modelParams._g1Val),
  g2Val("g2Val","g2Val",this,_modelParams._g2Val),
  g3Val("g3Val","g3Val",this,_modelParams._g3Val),
  g4Val("g4Val","g4Val",this,_modelParams._g4Val),
  g1ValIm("g1ValIm","g1ValIm",this,_modelParams._g1ValIm),
  g2ValIm("g2ValIm","g2ValIm",this,_modelParams._g2ValIm),
  g3ValIm("g3ValIm","g3ValIm",this,_modelParams._g3ValIm),
  g4ValIm("g4ValIm","g4ValIm",this,_modelParams._g4ValIm),

  fa2("fa2","fa2",this,_modelParams._fa2),
  fa3("fa3","fa3",this,_modelParams._fa3),
  phia2("phia2","phia2",this,_modelParams._phia2),
  phia3("phia3","phia3",this,_modelParams._phia3),

  mZ("mZ","mZ",this,_modelParams._mZ),
  gamZ("gamZ","gamZ",this,_modelParams._gamZ),
  mX("mX","mX",this,_modelParams._mX),
  R1Val("R1Val","R1Val",this,_modelParams._R1Val),
  R2Val("R2Val","R2Val",this,_modelParams._R2Val),
  // acceptance parameters
  aPhi("aPhi","aPhi",this,_accepParams._aPhi),
  bPhi("bPhi","bPhi",this,_accepParams._bPhi),  
  cPhi("cPhi","cPhi",this,_accepParams._cPhi),
  dPhi("dPhi","dPhi",this,_accepParams._dPhi),
  ePhi("ePhi","ePhi",this,_accepParams._ePhi),
  aPhi1("aPhi1","aPhi1",this,_accepParams._aPhi1),
  bPhi1("bPhi1","bPhi1",this,_accepParams._bPhi1),  
  cPhi1("cPhi1","cPhi1",this,_accepParams._cPhi1),
  dPhi1("dPhi1","dPhi1",this,_accepParams._dPhi1),
  ePhi1("ePhi1","ePhi1",this,_accepParams._ePhi1),
  aH1("aH1","aH1",this,_accepParams._aH1),
  bH1("bH1","bH1",this,_accepParams._bH1),  
  cH1("cH1","cH1",this,_accepParams._cH1),
  dH1("dH1","dH1",this,_accepParams._dH1),
  eH1("eH1","eH1",this,_accepParams._eH1),
  aH2("aH2","aH2",this,_accepParams._aH2),
  bH2("bH2","bH2",this,_accepParams._bH2),  
  cH2("cH2","cH2",this,_accepParams._cH2),
  dH2("dH2","dH2",this,_accepParams._dH2),
  eH2("eH2","eH2",this,_accepParams._eH2),
  aHs("aHs","aHs",this,_accepParams._aHs),
  bHs("bHs","bHs",this,_accepParams._bHs),  
  cHs("cHs","cHs",this,_accepParams._cHs),
  dHs("dHs","dHs",this,_accepParams._dHs),
  eHs("eHs","eHs",this,_accepParams._eHs)
{
}
  

RooSpinZero_7DComplex_withAccep::RooSpinZero_7DComplex_withAccep(const RooSpinZero_7DComplex_withAccep& other, const char* name) :
  RooAbsPdf(other,name),
  m1("m1",this,other.m1),
  m2("m2",this,other.m2),
  h1("h1",this,other.h1),
  h2("h2",this,other.h2),
  hs("hs",this,other.hs),
  Phi("Phi",this,other.Phi),
  Phi1("Phi1",this,other.Phi1),
  a1Val("a1Val",this,other.a1Val),
  phi1Val("phi1Val",this,other.phi1Val),
  a2Val("a2Val",this,other.a2Val),
  phi2Val("phi2Val",this,other.phi2Val),
  a3Val("a3Val",this,other.a3Val),
  phi3Val("phi3Val",this,other.phi3Val),
  parameterization(other.parameterization),
  g1Val("g1Val",this,other.g1Val),
  g2Val("a2Val",this,other.g2Val),
  g3Val("g3Val",this,other.g3Val),
  g4Val("g4Val",this,other.g4Val),
  g1ValIm("g1ValIm",this,other.g1ValIm),
  g2ValIm("a2ValIm",this,other.g2ValIm),
  g3ValIm("g3ValIm",this,other.g3ValIm),
  g4ValIm("g4ValIm",this,other.g4ValIm),

  fa2("fa2",this,other.fa2),
  fa3("fa3",this,other.fa3),
  phia2("phia2",this,other.phia2),
  phia3("phia3",this,other.phia3),

  mZ("mZ",this,other.mZ),
  gamZ("gamZ",this,other.gamZ),
  mX("mX",this,other.mX),
  R1Val("R1Val",this,other.R1Val),
  R2Val("R2Val",this,other.R2Val),
  // acceptance parameters
  aPhi("aPhi",this,other.aPhi),
  bPhi("bPhi",this,other.bPhi),
  cPhi("cPhi",this,other.cPhi),
  dPhi("dPhi",this,other.dPhi),
  ePhi("ePhi",this,other.ePhi),
  aPhi1("aPhi1",this,other.aPhi1),
  bPhi1("bPhi1",this,other.bPhi1),
  cPhi1("cPhi1",this,other.cPhi1),
  dPhi1("dPhi1",this,other.dPhi1),
  ePhi1("ePhi1",this,other.ePhi1),
  aH1("aH1",this,other.aH1),
  bH1("bH1",this,other.bH1),
  cH1("cH1",this,other.cH1),
  dH1("dH1",this,other.dH1),
  eH1("eH1",this,other.eH1),
  aH2("aH2",this,other.aH2),
  bH2("bH2",this,other.bH2),
  cH2("cH2",this,other.cH2),
  dH2("dH2",this,other.dH2),
  eH2("eH2",this,other.eH2),
  aHs("aHs",this,other.aHs),
  bHs("bHs",this,other.bHs),
  cHs("cHs",this,other.cHs),
  dHs("dHs",this,other.dHs),
  eHs("eHs",this,other.eHs)
{
}



Double_t RooSpinZero_7DComplex_withAccep::evaluate() const
{

  // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE
  //   const Double_t VEV = 246.;

  Double_t Pi = 3.14159265359;
  Double_t sh1 = sqrt(1-h1*h1);
  Double_t sh2 = sqrt(1-h2*h2);
    
  bool isZZ = true;
  if ( mZ < 90.) isZZ = false;
  if ( isZZ ) {
    if( (m1+m2) > mX || m2>m1 ) return 1e-9;
  } else {
    if( (m1+m2) > mX ) return 1e-9;
  }
  double nanval = sqrt((1 - TMath::Power(m1 - m2,2)/TMath::Power(mX,2))*(1 - TMath::Power(m1 + m2,2)/TMath::Power(mX,2)));
  if (nanval != nanval) return 1e-9;
    
  double s=(mX*mX-m1*m1-m2*m2)/2.;
  double kappa=s/(1000*1000);
    
  double a1=0,a2=0,a3=0,a1Im=0,a2Im=0,a3Im=0;
  double g1(1.0), g1Im(0.), g2(0.), g2Im(0.), g3(0.), g3Im(0.), g4(0.), g4Im(0.);

  if(parameterization==kMagPhase_As){
    a1=a1Val;
    a1Im=phi1Val;
    a2=a2Val;
    a2Im=phi2Val;
    a3=a3Val;
    a3Im=phi3Val;
  } else {

    // 
    // Important, the PDF has an emphirical fix
    // Forcing the couplings to be its conjugate 
    // to agree with the generator shapes
    // 
    if(parameterization==kFracPhase_Gs){
      nanval = sqrt(1 - fa2 - fa3);
      if (nanval != nanval) return 1e-9;

      // convert fraction and phase to g1,g2...etc
      double sigma_1=2.0418442;   // numbers coming from JHUGen
      double sigma_2=0.77498928;
      double sigma_4=0.32711197;
      
      double g1Mag = 1.;
      double g2Mag = sqrt(fa2/(1.-fa2-fa3))*sqrt(sigma_1/sigma_2); 
      double g4Mag = sqrt(fa3/(1.-fa2-fa3))*sqrt(sigma_1/sigma_4); 
      
      g1   = g1Mag;
      g1Im = 0.0;
      g2   = g2Mag*cos(phia2);
      g2Im = - g2Mag*sin(phia2);
      g3   = 0.0;
      g3Im = 0.0;
      g4   = g4Mag*cos(phia3);
      g4Im = - g4Mag*sin(phia3);
      
    }else if(parameterization==kRealImag_Gs){
      
      g1   = g1Val;
      g1Im = - g1ValIm;
      g2   = g2Val;
      g2Im = - g2ValIm;
      g3   = g3Val;
      g3Im = - g3ValIm;
      g4   = g4Val;
      g4Im = - g4ValIm;
    }
    
    a1 = g1*mZ*mZ/(mX*mX) + g2*2.*s/(mX*mX) + g3*kappa*s/(mX*mX);
    a1Im = g1Im*mZ*mZ/(mX*mX) + g2Im*2.*s/(mX*mX) + g3Im*kappa*s/(mX*mX);
    a2 = -2.*g2 - g3*kappa;
    a2Im = -2.*g2Im - g3Im*kappa;
    a3 = -2.*g4;
    a3Im = -2.*g4Im;

  }
  
  // From the form output in terms of the g couplings
  // https://dl.dropbox.com/u/86680464/result_spin0.txt
  Double_t x = (mX*mX-m1*m1-m2*m2)/(2.0*m1*m2);
  Double_t f00Real =
    a2 * (  - (x*x-1)*m1*m2 )
    + a1 * ( 1./4.*TMath::Power(m1, -1)*TMath::Power(m2, 3) - 1./2.*m1*m2 + 1./4.*TMath::Power(m1,3)*TMath::Power(m2,-1) - (x*x-1)*m1*m2 )
    + TMath::Power(mX,4)*a1 * (  - 1./4.*TMath::Power(m1,-1)*TMath::Power(m2,-1) );
  //    Double_t f00Imag = 0.;
  Double_t f00Imag =     
    a2Im * (  - (x*x-1)*m1*m2 )
    + a1Im * ( 1./4.*TMath::Power(m1, -1)*TMath::Power(m2, 3) - 1./2.*m1*m2 + 1./4.*TMath::Power(m1,3)*TMath::Power(m2,-1) - (x*x-1)*m1*m2 )
    + TMath::Power(mX,4)*a1Im * (  - 1./4.*TMath::Power(m1,-1)*TMath::Power(m2,-1) );
    
  //    Double_t fppReal = TMath::Power(mX, 2)*a1;
  //    Double_t fppImag = a3*sqrt(x*x-1)*m1*m2 ;
  Double_t fppReal = TMath::Power(mX, 2)*a1 - a3Im*sqrt(x*x-1)*m1*m2;
  Double_t fppImag = a3*sqrt(x*x-1)*m1*m2 + TMath::Power(mX, 2)*a1Im;
    
  Double_t fmmReal = TMath::Power(mX, 2)*a1 + a3Im*sqrt(x*x-1)*m1*m2;
  Double_t fmmImag = -a3*sqrt(x*x-1)*m1*m2 + TMath::Power(mX, 2)*a1Im;
    
  Double_t f00 = f00Imag*f00Imag + f00Real*f00Real;
  Double_t fpp = fppImag*fppImag + fppReal*fppReal;
  Double_t fmm = fmmImag*fmmImag + fmmReal*fmmReal;
    
  Double_t phi00=atan2(f00Imag,f00Real);
  Double_t phipp=atan2(fppImag,fppReal)-phi00;
  Double_t phimm=atan2(fmmImag,fmmReal)-phi00;
    
    
  Double_t betaValSquared = (1.-(pow(m1-m2,2)/pow(mX,2)))*(1.-(pow(m1+m2,2)/pow(mX,2)));
  Double_t betaVal = sqrt(betaValSquared);
    
  Double_t term1Coeff = (pow(m1,3))/( (pow(m1,2)-pow(mZ,2))*(pow(m1,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );
  Double_t term2Coeff = (pow(m2,3))/( (pow(m2,2)-pow(mZ,2))*(pow(m2,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );

  // BELOW GOES THE test_Decay.txt OUTPUT FROM Master_yy.nb
    
  double value = 0.;

  <<<EVALUATE>>>
        
  return  betaVal*term1Coeff*term2Coeff*value;
    
    
}


Int_t RooSpinZero_7DComplex_withAccep::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const
{

  if (matchArgs(allVars,analVars,RooArgSet(*hs.absArg(),*h1.absArg(),*h2.absArg(),*Phi.absArg(),*Phi1.absArg()))) return 6 ; // No m1,m2
  if (matchArgs(allVars,analVars,hs,h1,h2,Phi)) return 2 ; // No Phi1
  if (matchArgs(allVars,analVars,hs,h1,h2,Phi1)) return 5 ; // No Phi
  if (matchArgs(allVars,analVars,hs,h1,Phi,Phi1)) return 3 ; // No h2
  if (matchArgs(allVars,analVars,hs,h2,Phi,Phi1)) return 4 ; // No h1
  if (matchArgs(allVars,analVars,h1,h2,Phi,Phi1)) return 1 ; // No hs
  
  return 0 ;
}
Double_t RooSpinZero_7DComplex_withAccep::analyticalIntegral(Int_t code, const char* rangeName) const
{
    
  bool isZZ = true;
  if ( mZ < 90.) isZZ = false;
  if ( isZZ ) {
    if( (m1+m2) > mX || m2>m1 ) return 1e-9;
  } else {
    if( (m1+m2) > mX ) return 1e-9;
  }
  double nanval = sqrt((1 - TMath::Power(m1 - m2,2)/TMath::Power(mX,2))*(1 - TMath::Power(m1 + m2,2)/TMath::Power(mX,2)));
  if (nanval != nanval) return 1e-9;
  
  //
  //  common variables to use for all cases
  //

  Double_t Pi = 3.14159265359;

  Double_t sh1 = sqrt(1-h1*h1);
  Double_t sh2 = sqrt(1-h2*h2);
  double s=(mX*mX-m1*m1-m2*m2)/2.;
  double kappa=s/(1000*1000);
    
  double a1=0,a2=0,a3=0,a1Im=0,a2Im=0,a3Im=0;

  double g1(1.0), g1Im(0.), g2(0.), g2Im(0.), g3(0.), g3Im(0.), g4(0.), g4Im(0.);

  if(parameterization==kMagPhase_As){
    a1=a1Val;
    a1Im=phi1Val;
    a2=a2Val;
    a2Im=phi2Val;
    a3=a3Val;
    a3Im=phi3Val;
  } else {

    // 
    // Important, the PDF has an emphirical fix
    // Forcing the couplings to be its conjugate 
    // to agree with the generator shapes
    // 
    if(parameterization==kFracPhase_Gs){
      nanval = sqrt(1 - fa2 - fa3);
      if (nanval != nanval) return 1e-9;
      
      // convert fraction and phase to g1,g2...etc
      double sigma_1=2.0418442;   // numbers coming from JHUGen
      double sigma_2=0.77498928;
      double sigma_4=0.32711197;
      
      double g1Mag = 1.;
      double g2Mag = sqrt(fa2/(1.-fa2-fa3))*sqrt(sigma_1/sigma_2); 
      double g4Mag = sqrt(fa3/(1.-fa2-fa3))*sqrt(sigma_1/sigma_4); 
      
      g1   = g1Mag;
      g1Im = 0.0;
      g2   = g2Mag*cos(phia2);
      g2Im = - g2Mag*sin(phia2);
      g3   = 0.0;
      g3Im = 0.0;
      g4   = g4Mag*cos(phia3);
      g4Im = - g4Mag*sin(phia3);
      
    }else if(parameterization==kRealImag_Gs){
      
      g1   = g1Val;
      g1Im = - g1ValIm;
      g2   = g2Val;
      g2Im = - g2ValIm;
      g3   = g3Val;
      g3Im = - g3ValIm;
      g4   = g4Val;
      g4Im = - g4ValIm;
    }
    
    // std::cout << "g4 = " << g4 << "\t " << "i " << g4Im << "\n";
    a1 = g1*mZ*mZ/(mX*mX) + g2*2.*s/(mX*mX) + g3*kappa*s/(mX*mX);
    a1Im = g1Im*mZ*mZ/(mX*mX) + g2Im*2.*s/(mX*mX) + g3Im*kappa*s/(mX*mX);
    a2 = -2.*g2 - g3*kappa;
    a2Im = -2.*g2Im - g3Im*kappa;
    a3 = -2.*g4;
    a3Im = -2.*g4Im;

  }
  
  // From the form output in terms of the g couplings
  // https://dl.dropbox.com/u/86680464/result_spin0.txt
  Double_t x = (mX*mX-m1*m1-m2*m2)/(2.0*m1*m2);
  Double_t f00Real =
    a2 * (  - (x*x-1)*m1*m2 )
    + a1 * ( 1./4.*TMath::Power(m1, -1)*TMath::Power(m2, 3) - 1./2.*m1*m2 + 1./4.*TMath::Power(m1,3)*TMath::Power(m2,-1) - (x*x-1)*m1*m2 )
    + TMath::Power(mX,4)*a1 * (  - 1./4.*TMath::Power(m1,-1)*TMath::Power(m2,-1) );
  //    Double_t f00Imag = 0.;
  Double_t f00Imag =     
    a2Im * (  - (x*x-1)*m1*m2 )
    + a1Im * ( 1./4.*TMath::Power(m1, -1)*TMath::Power(m2, 3) - 1./2.*m1*m2 + 1./4.*TMath::Power(m1,3)*TMath::Power(m2,-1) - (x*x-1)*m1*m2 )
    + TMath::Power(mX,4)*a1Im * (  - 1./4.*TMath::Power(m1,-1)*TMath::Power(m2,-1) );
    
  //    Double_t fppReal = TMath::Power(mX, 2)*a1;
  //    Double_t fppImag = a3*sqrt(x*x-1)*m1*m2 ;
  Double_t fppReal = TMath::Power(mX, 2)*a1 - a3Im*sqrt(x*x-1)*m1*m2;
  Double_t fppImag = a3*sqrt(x*x-1)*m1*m2 + TMath::Power(mX, 2)*a1Im;
    
  Double_t fmmReal = TMath::Power(mX, 2)*a1 + a3Im*sqrt(x*x-1)*m1*m2;
  Double_t fmmImag = -a3*sqrt(x*x-1)*m1*m2 + TMath::Power(mX, 2)*a1Im;
    
  Double_t f00 = f00Imag*f00Imag + f00Real*f00Real;
  Double_t fpp = fppImag*fppImag + fppReal*fppReal;
  Double_t fmm = fmmImag*fmmImag + fmmReal*fmmReal;
    
  Double_t phi00=atan2(f00Imag,f00Real);
  Double_t phipp=atan2(fppImag,fppReal)-phi00;
  Double_t phimm=atan2(fmmImag,fmmReal)-phi00;
    
  Double_t betaValSquared = (1.-(pow(m1-m2,2)/pow(mX,2)))*(1.-(pow(m1+m2,2)/pow(mX,2)));
  Double_t betaVal = sqrt(betaValSquared);
    
  Double_t term1Coeff = (pow(m1,3))/( (pow(m1,2)-pow(mZ,2))*(pow(m1,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );
  Double_t term2Coeff = (pow(m2,3))/( (pow(m2,2)-pow(mZ,2))*(pow(m2,2)-pow(mZ,2))+pow(mZ,2)*pow(gamZ,2) );
    
  switch(code)
    {
      // projections to hs
    case 1:
      {

	// test_InteNoHs.txt

        double value = 0.;
        
	<<<HSPROJ>>>

        return betaVal*term1Coeff*term2Coeff*value;
 
      }
      // projections to Phi1
    case 2:
      {
	
	// from test_IntNoPhi1.txt

        double value = 0.;
        
	<<<PHI1PROJ>>>

        return betaVal*term1Coeff*term2Coeff*value;

      }
      // projections to h2
    case 3:
      {

	// from test_IntNoH2.txt

        double value = 0.;

	<<<H2PROJ>>>

        return betaVal*term1Coeff*term2Coeff*value;

      }
      // projections to h1
    case 4:
      {

	// from test_IntNoH1.txt

        double value = 0.;

	<<<H1PROJ>>>

        return betaVal*term1Coeff*term2Coeff*value;

      }
      // projections to Phi
    case 5:
      {

	// from test_IntNoPhi.txt
	
        double value = 0.;

	<<<PHIPROJ>>>

        return betaVal*term1Coeff*term2Coeff*value;

      }
      // projections to mz1/mz2
    case 6:
      {
	
	// from test_IntAll.txt

        double value = 0.;

	<<<MZPROJ>>>

        return betaVal*term1Coeff*term2Coeff*value;

      }

    }
  assert(0) ;
  return 0 ;
}


